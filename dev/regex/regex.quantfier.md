정규 표현식 - 수량자(quantifier)
http://sweeper.egloos.com/3064600

```
1. 수량자(quantifier)

지금까지 정규 표현식이 하나의 문자나 문자열에 일치하는 방법에 대해 살펴보았다.
정규 표현식 - 문자 검색
정규 표현식 - 문자 집합으로 찾기
정규 표현식 - 다양한 메타 문자들

하지만, 지금까지 배운 것들은 기초적인 표현식 사용법일 뿐,
실질적으로 정규 표현식만의 강력한 검색 기능이라고 느껴질만한 것은 없었다.
하나의 문자나 문자열을 일치시키는 것은 정규 표현식을 쓰지 않더라도 충분히 가능하기 때문이다.

이메일 주소의 적합성을 체크해야 하는 경우를 생각해 보자.
일반적인 문자/문자열 검색 기능으로는 이를 해결하기가 무척 복잡하다.
이럴 때 정규 표현식의 진가가 드러나는데, 지금까지 배운 내용만으로는 아래 예제와 같은 한계에 부딪힌다.

이메일 주소의 기본 형식은 text@text.text 과 같다.
지금까지 배운 메타 문자들을 활용해 정규 표현식을 아래와 같이 작성해 보자.

[정규 표현식]
\w\@\w\.\w

위 정규 표현식은 문법은 완벽하지만, "a@b.c" 와 같은 녀석들만 체크가 가능하기에, 사실상 이메일 체커로써는 의미가 없다.
문제는 "\w"를 통해 영숫자와 _(언더바)를 일치시킬 수 있지만, 얼마나 많은 문자를 검사해야 할 지 모른다는 점이다.

이러한 문제들을 해결하기 위해 정규 표현식은 수량자(quantifier)를 제공한다.
정규 표현식의 수량자는 문자, 문자 집합, 그리고 클래스 메타 문자의 인스턴스가 몇 개 있어야 일치되는지를 지정한다.
수량자는 다음과 같은 것들이 있다.
+(더하기)
*(별표)
?(물음표)
{n}
{min,max}
{min,}

지금부터 하나씩 어떤 의미를 가지는지 어떻게 사용하는지 살펴보기로 하자.


2. 문자 하나 이상 찾기

문자나 집합에 속한 요소를 하나 이상 찾으려면 간단히 문자 뒤에 +(더하기) 메타 문자를 붙이면 된다.
+(더하기)는 문자가 하나 이상일 때 일치한다. (하나 이상이니까 없는 경우엔 일치하지 않는다)

정규 표현식 a가 하나의 "a"를 찾는 데 반해, a+는 하나 이상의 연속된 "a"를 찾을 수 있다.
비슷하게, [0-9](또는 \d)가 하나의 숫자를 찾는 데 반해, [0-9]+(또는 \d+)는 하나 이상의 연속된 숫자를 찾을 수 있다.

문자 집합([])에 문자를 하나 이상 찾으려 +(더하기)를 사용할 때는 반드시 +(더하기)를 문자 집합 밖에서 붙여야 한다.
그렇지 않으면, 문자 집합에 "+" 문자를 추가하는 것의 의미를 가진다.

앞서 이메일 체커의 한계를 +(더하기) 메타 문자를 활용해 조금 더 의미있게 만들어 보자.

[예문]
Send email to SooKkaRak@me.com or Soo.Kka.Rak@me.com.
For questions about a carrer use SooKkaRak@linkedin.com.
If ur message is urent, try SooKkaRak@urgent.me.com.

[정규 표현식]
\w+\@\w+\.\w+

[결과]
Send email to SooKkaRak@me.com or Soo.Kka.Rak@me.com.
For questions about a carrer, use SooKkaRak@linkedin.com.
If your message is urent, try SooKkaRak@urgent.me.com.

text@text.text를 표현하려고...
첫번째 text를 표현하기 위해 : \w+
@(앳)을 표현하기 위해 : \@ (@는 이스케이프가 없어도 되지만, 이스케이프를 붙이는 게 낫다)
두번째 text를 표현하기 위해 : \+
.(마침표)을 표현하기 위해 : \. (이스케이프가 꼭 필요)
세번째 text를 표현하기 위해 : \w+

하지만, 예제에서 보았듯이 유효한 이메일 주소 형식은 (text.text...)@(text.text...).text 이었던 것이다.

따라서, 위 예제에서 사용했던 정규 표현식만으로는 예문에 나와있는 모든 이메일 주소를 찾아낼 수 없다.
이번엔 문자 집합을 활용하여, 첫번째 예제를 조금 더 보완시켜 보자.

[정규 표현식]
[\w\.]+\@[\w\.]+\.\w+

[결과]
Send email to SooKkaRak@me.com or Soo.Kka.Rak@me.com.
For questions about a carrer, use SooKkaRak@linkedin.com.
If your message is urent, try SooKkaRak@urgent.me.com.

text.text... 를 표현하기 위해 \w+ 대신 [\w\.]+ 즉, 영숫자, _(언더바), .(마침표)의 집합을 통해 문제를 해결하였다,
앞서도 이야기했지만, 문자 집합([])을 하나 이상 있을 경우 일치시키려면, 문자 집합([]) 밖에 +(더하기)를 붙여야 한다.

하지만, 이게 온전한 이메일을 체크하는 정규 표현식의 최종 답안일까?


3. 문자가 없거나 하나 이상 있는 경우 찾기

+(더하기)는 하나 이상 연속된 문자를 찾는다.
문자가 없는 경우는 아예 찾지 못하고, 최소한 하나는 일치해야 한다.
하지만, 있을 수도 있고 없을 수도 있는 문자와 일치시키려면 어떻게 해야 할까?

*(별표)는 찾고자 하는 문자나 집합이 없는 경우 또는 하나 이상 연속하는 경우에 일치한다.

그러면, 이메일 체커 정규 표현식을 한번 더 살펴보자.

[예문]
My email address is .SooKkaRak@me.com.

[정규 표현식]
[\w\.]+\@[\w\.]+\.\w+

[결과]
My email address is .SooKkaRak@me.com.

앞서 +(더하기)만 활용했을 때의 허점이 보이는가?
영숫자, _(언더바), .(마침표)의 문자 집합이 하나 이상 있고, 뒤에 @(앳)이 오는 것이 이메일 주소 전반에 대한 정규 표현식이라, 지금의 예제처럼 이메일 주소의 처음이 .(마침표)인 것에 대해서는 제대로 검출이 불가능한 것이다.

이 정규 표현식의 허점을 아래와 같이 고치면 이제는 이메일 체크 정규 표현식이 완벽해진다.

[정규 표현식]
\w+[\w\.]*\@\w+[\w\.]*\.\w+

[결과]
My email address is .SooKkaRak@me.com.

영숫자로 시작하되 text.text...@text.text....text의 형식을 만족시키기 위해
영숫자로 시작하기 위해 : \w+
있을 수도 없을 수도 있는 text.text...를 표현하기 위해 : [\w\.]*

더 장확하게 하자면, 마지막 .(마침표) 이후엔 영문자만 와야 하므로 \w+ 대신 아래 정규 표현식처럼 하는 게 맞다.

[정규 표현식]
\w+[\w\.]*\@\w+[\w\.]*\.[A-Za-z]+

이제 이메일 체커 정규 표현식이 완성된 듯 하다.

다시 정리하자면,
+(더하기)는 주어진 문자가 반드시 하나 이상 있어야 일치하고,
*(별표)는 주어진 문자가 없던 하나 이상 있던 일치한다.


4. 문자가 없거나 하나만 있는 경우 찾기

*(별표)는 주어진 문자가 없던 하나 이상 있던 일치하지만,
?(물음표)는 주어진 문자가 없던 딱 하나만 있는 경우 일치한다.

*(별표)에 비해 ?(물음표)가 협의의 기능을 제공하는데 언제 쓸모가 있을까?
아래 예제에서 프로토콜 부분만 일치시키는 정규 표현식을 살펴보자.

[예문]
http://sweeper.egloos.com
https://sweeper.egloos.com/secure

[정규 표현식]
https?

[결과]
http://sweeper.egloos.com
https://sweeper.egloos.com/secure

s?는 s가 없거나 s가 딱 하나만 있는 경우 일치한다.
만약, s?가 아닌 s*로 정규 표현식을 작성하였다면, httpssssss: 등 잘못된 프로토콜까지 일치가 되는 것이다.

"정규 표현식 - 다양한 메타 문자들" 문서의 "공백 메타 문자" 챕터에서 \r\n 공백 문자에 대해 이야기하였다.
\r(캐리지 리턴)은 윈도우 시스템에서만 사용하기에, \r(캐리지 리턴)은 있거나 없거나, 그리고 \n(뉴라인)은 꼭 있어야 하는 정규 표현식을 작성해야 플랫폼 구분 없이 공백 라인을 검색할 수 있다 하였다.

[정규 표현식]
\r?\n

\r? 을 통해 \r(캐리지 리턴)은 있거나 없거나 처리를 할 수 있게 되었다.


5. 구간 설정

+(더하기), *(별표), ?(물음표)는 정규 표현식을 쓰면서 발생하는 많은 문제를 해결해 주지만, 충분하지 않을 때도 있다.
다음과 같은 상황을 생각해 보자.
+(더하기)와 *(별표)는 일치하는 문자 수에 제한이 없다. 문자가 최대 몇개까지 일치하는지 정할 수 없다.
+(더하기), *(별표), ?(물음표)가 일치하는 문자 수의 최소값은 0이나 1이다. 최소값을 명시적으로 지정할 수 없다.
+(더하기)와 *(별표) 사용시 정확히 원하는 만큼만 일치시키도록 문자 수를 지정할 수 없다.

즉, 일치시킬 문자 수의 최소, 최대 범위를 지정할 수 없고, 정확히 몇개를 일치시킬 지 정할 수 없다는 것이다.

이러한 문제들을 해결하고, 연속하는 문자를 찾을 때 검색 조건을 더 구체적으로 지정하고자, 구간(interval)을 사용한다.
구간은 중괄호({}) 안에 표시한다.

그럼 구간을 설정하는 방식에 대해 살펴보자.
구간을 지정하고 싶은 문자나 집합 뒤에...
{n} : 정확히 n개를 일치시킨다.
{min, max} : 최소 min에서 최대 max까지 일치시킨다. ?(물음표)는 {0,1}과 동일하다 할 수 있다.
{min,} : 최소 min개를 일치시킨다. +(더하기)는 {1,} 동일하다 할 수 있다.

구간으로 범위({min, max}) 설정시 min < max를 지켜주어야 함을 잊지 말자.
최대값만 지정하고 싶은 경우에는 {0,max}를 사용하면 된다. 

1) {n}

"정규 표현식 - 문자 집합으로 찾기" 문서의 "문자 집합 사용하기" 챕터에 나왔던 정규 표현식은 아래와 같이 정리할 수 있다.

[정규 표현식]
#[A-Fa-f0-9][A-Fa-f0-9][A-Fa-f0-9][A-Fa-f0-9][A-Fa-f0-9][A-Fa-f0-9]

[정규 표현식]
#?[A-Fa-f0-9]{6}

2) {min, max}

mm-dd-yyyy 또는 mm-dd-yy 날짜 형식을 찾는 예제를 살펴보자.
(물론, 정규 표현식으로는 그 문자가 가지는 의미까지 해석이 불가하기에 99-99-9999같은 건 추려내지 못한다)

[예문]
4/8/02
10-6-2004
2/2/2
01-01-01

[정규 표현식]
\d{1,2}[\/\-]\d{1,2}[\/\-]\d{2,4}

[결과]
4/8/02
10-6-2004
2/2/2
01-01-01

마지막 yy 또는 yyyy를 일치시키기 위해 {2,4}를 설정하였고, 그 결과 2/2/2는 일치하지 않았다.

3) {min,}

아래 주문표에서 100 달러가 넘는 주문만 찾아보도록 하자

[예문]
1001: $496.80
1002: $1290.69
1003: $26.43
1004: $613.42
1005: $7.61
1006: $25.00

[정규 표현식]
\d+: \$\d{3,}\.\d+

[결과]
1001: $496.80
1002: $1290.69
1003: $26.43
1004: $613.42
1005: $7.61
1006: $25.00

원자릿수가 최소 3글자 표기된 문자를 일치시켜 원하는 결과를 얻을 수 있었다.


6. 탐욕적 수량자 vs 게으른 수량자

여러 수량자에는 두 가지 버전이 존재한다.
탐욕적(greedy) 수량자 : 요소를 찾을 때 최대한 많은 요소를 적용 (뒤에서부터 검색)
게으른(lazy) 수량자 : 요소를 찾을 때 최대한 적은 요소를 적용 (앞에서부터 검색)

지금까지 위에서 정리한 모든 수량자는 탐욕적 수량자이다.

탐욕적이라는 것의 의미를 이해하기 위해 다음 예제를 살펴보자.
다음 예제에서는 정규 표현식으로 <B> ... </B> 태그로 둘러싸인 텍스트를 찾으려 한다.

[예문]
This offer isn't available to customers
living in <B>AK</B> and <B>HI</B>

[정규 표현식]
\<[Bb]\>.*\<\/[Bb]\>

[결과]
This offer isn't available to customers
living in <B>AK</B> and <B>HI</B>

검색하려 했던 <B>AK</B>와 <B>HI</B>가 아닌 두개가 합쳐진 녀석이 일치되었다고 나와 버렸다.
이것이 바로 탐욕적 수량자의 일치 방식이다.

<B>로 시작해서 문자열이 있고 </B>로 끝나는 것을 최대한 많이 포함하여 가장 큰 결과를 (탐욕적으로) 얻어내는 것이다.
이를 위해서 탐욕적 수량자는 앞에서부터 끊어 일치시키는 방식이 아닌, 뒤에서부터 덩어리로 크게 일치시키는 방식을 사용한다.

그러면 애초 원했던 결과를 얻으려면 어떻게 해야 할까?
바로, 게으른 수량자를 사용하는 것이다.

게으른 수량자는 기존의 (탐욕적) 수량자 뒤에 ?(물음표)를 붙여 사용하면 된다.
+ -> +?
* -> *?
? -> ??
{n} -> {n}?
{min,max} -> {min,max}?
{min,} -> {min,}?

모든 수량자가 탐욕적/게으른의 두 가지 버전을 가지긴 한다만, 
사실 게으른 수량자가 의미 있는 것은 최대값이 명시되지 않은 녀석들이다. 
즉, 아래 세 녀석의 게으른 수량자는 자주 사용되므로 잘 봐 두어야 한다.
+?
*?
{min,}?

그러면, 앞의 예제를 다시 게으른 수량자로 바꾸어 문제를 해결해 보자.

[정규 표현식]
\<[Bb]\>.*?\<\/[Bb]\>

[결과]
This offer isn't available to customers
living in <B>AK</B> and <B>HI</B>

근데 사실 이 예제는 게으른 수량자를 보여주기 위함이고, 다음과 같이 정규 표현식을 짜도 문제가 없긴 하다.

[정규 표현식]
\<[Bb]\>\w+\<\/[Bb]\>

\w+에는 영숫자와 _(언더바)만 포함되기에, 바로 \<에서 걸리기 때문이다.


7. 정리

정규 표현식이 지닌 진짜 능력은 반복 찾기를 할 때 뚜렷하게 나타난다.
+(더하기)를 통해 하나 이상 일치
*(별표)를 통해 없거나 하나 이상 일치
?(물음표)를 통해 없거나 하나만 일치
구간으로 정확한 횟수({n})나 최소,최대의 범위 지정({min,max}, {min,}) 지정
위의 수량자들은 기본적으로 탐욕적이어서 너무 넓은 범위와 일치할 수 있다.
이를 방지하고자 게으른 수량자를 사용하기도 한다.
```